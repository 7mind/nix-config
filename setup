#!/usr/bin/env bash

set -e

# Master identity pubkeys for each group
declare -A group_pubkeys

# TPM-protected identity paths (can be overridden in private/setup-env)
AGE_TPM_IDENTITY="${AGE_TPM_IDENTITY:-${HOME}/.age/tpm-identity.txt}"
AGE_MASTER_KEY_TPM="${AGE_MASTER_KEY_TPM:-${HOME}/.age/master-key.age}"
# Runtime decryption path - must match defaults in age.nix module
if [[ "$(uname -s)" == "Darwin" ]]; then
    AGE_RUNTIME_KEY="/tmp/age-master-key"
else
    AGE_RUNTIME_KEY="/dev/shm/age-master-key"
fi
AGE_DECRYPTED_KEY=""  # Set during rekey

THISHOST="$(hostname -s)"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOTS=/nix/var/nix/gcroots/my-builds

# Source private environment if it exists
[[ -f "$SCRIPT_DIR/private/setup-env" ]] && source "$SCRIPT_DIR/private/setup-env"

# Options
HOSTS=()
DO_REFRESH=false
DO_SWITCH=false
DO_REKEY=false
DO_GIT=true
DO_LIST=false
MESSAGE=""
VERBOSE=false

# Cache for host metadata
declare -A HOST_META

usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS] [HOST...]

Build and deploy NixOS/nix-darwin configurations.

If no HOST is specified, builds the current host (${THISHOST}).

Options:
  -s, --switch      Switch to the new configuration after building
  -k, --rekey       Rekey age secrets for the specified hosts before building
  -r, --refresh     Update flake inputs before building
  -n, --no-git      Skip git commit and push
  -m, --message=MSG Custom git commit message (default: "autosave (<host> / <os>)")
  -l, --list        List known hosts and exit
  -v, --verbose     Enable verbose output (set -x)
  -h, --help        Show this help message

Host specifiers:
  HOST                 Individual host name (e.g., o1, pavel-fw)
  +GROUP               All hosts in a group (e.g., +infra, +pavel)

Examples:
  $(basename "$0")                  # Build current host
  $(basename "$0") -s               # Build and switch current host
  $(basename "$0") -k -s            # Rekey, build, and switch current host
  $(basename "$0") o1 o2            # Build o1 and o2
  $(basename "$0") +infra           # Build all hosts in 'infra' group
  $(basename "$0") -k +infra        # Rekey and build all infra hosts
  $(basename "$0") -r -s            # Update flake, build, and switch
  $(basename "$0") -n               # Build without git operations
EOF
    exit 0
}

load_host_meta() {
    echo "Loading host metadata from flake..."
    add_all
    local json
    json=$(nix eval ".?submodules=1#hostMeta" --json 2>/dev/null)

    # Parse JSON and populate HOST_META
    while IFS="=" read -r key value; do
        HOST_META["$key"]="$value"
    done < <(echo "$json" | jq -r 'to_entries[] | "\(.key)=\(.value | @json)"')
}

get_host_attr() {
    local host="$1"
    local attr="$2"
    local meta="${HOST_META[$host]}"
    if [[ -z "$meta" ]]; then
        echo ""
        return
    fi
    echo "$meta" | jq -r ".$attr // empty"
}

get_hosts_by_group() {
    local target_group="$1"
    local hosts=()
    for host in "${!HOST_META[@]}"; do
        local group
        group=$(get_host_attr "$host" "group")
        if [[ "$group" == "$target_group" ]]; then
            hosts+=("$host")
        fi
    done
    echo "${hosts[@]}"
}

get_current_platform() {
    case "$(uname -s)" in
        Darwin) echo "darwin" ;;
        Linux)  echo "linux" ;;
        *)      echo "unknown" ;;
    esac
}

expand_host_specifiers() {
    local current_platform
    current_platform=$(get_current_platform)
    local expanded=()

    for spec in "${HOSTS[@]}"; do
        if [[ "$spec" == +* ]]; then
            local group="${spec:1}"
            local group_hosts=()
            local skipped=()

            for host in "${!HOST_META[@]}"; do
                local host_group host_platform
                host_group=$(get_host_attr "$host" "group")
                host_platform=$(get_host_attr "$host" "platform")

                if [[ "$host_group" == "$group" ]]; then
                    if [[ "$host_platform" == "$current_platform" ]]; then
                        group_hosts+=("$host")
                    else
                        skipped+=("$host")
                    fi
                fi
            done

            if [[ ${#group_hosts[@]} -eq 0 ]]; then
                echo "Error: No buildable hosts found in group '$group' for platform '$current_platform'" >&2
                [[ ${#skipped[@]} -gt 0 ]] && echo "    (skipped incompatible: ${skipped[*]})" >&2
                echo "Use --list to see known hosts and their groups." >&2
                exit 1
            fi

            echo "    Expanding +$group: ${group_hosts[*]}"
            [[ ${#skipped[@]} -gt 0 ]] && echo "    (skipped incompatible: ${skipped[*]})"

            for h in "${group_hosts[@]}"; do
                expanded+=("$h")
            done
        else
            expanded+=("$spec")
        fi
    done
    HOSTS=("${expanded[@]}")
}

list_hosts() {
    load_host_meta
    echo "Known hosts:"
    printf "  %-16s %-8s %-8s %s\n" "HOST" "PLATFORM" "GROUP" "FQN"
    printf "  %-16s %-8s %-8s %s\n" "----" "--------" "-----" "---"
    for host in "${!HOST_META[@]}"; do
        local platform group fqn
        platform=$(get_host_attr "$host" "platform")
        group=$(get_host_attr "$host" "group")
        fqn=$(get_host_attr "$host" "fqn")
        [[ "$fqn" == "null" || -z "$fqn" ]] && fqn="(local)"
        printf "  %-16s %-8s %-8s %s\n" "$host" "$platform" "$group" "$fqn"
    done | sort
    exit 0
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -s|--switch)
                DO_SWITCH=true
                shift
                ;;
            -k|--rekey)
                DO_REKEY=true
                shift
                ;;
            -r|--refresh)
                DO_REFRESH=true
                shift
                ;;
            -n|--no-git)
                DO_GIT=false
                shift
                ;;
            -m|--message)
                MESSAGE="$2"
                shift 2
                ;;
            --message=*)
                MESSAGE="${1#*=}"
                shift
                ;;
            -m=*)
                MESSAGE="${1#*=}"
                shift
                ;;
            -l|--list)
                DO_LIST=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                usage
                ;;
            -*)
                echo "Error: Unknown option: $1" >&2
                echo "Use --help for usage information." >&2
                exit 1
                ;;
            *)
                HOSTS+=("$1")
                shift
                ;;
        esac
    done

    # Default to current host if none specified
    if [[ ${#HOSTS[@]} -eq 0 ]]; then
        HOSTS=("$THISHOST")
    fi

    # Default commit message
    if [[ -z "$MESSAGE" ]]; then
        MESSAGE="autosave ($(hostname) / $(uname))"
    fi
}

validate_hosts() {
    for host in "${HOSTS[@]}"; do
        if [[ -z "${HOST_META[$host]}" ]]; then
            echo "Error: Unknown host '$host'" >&2
            echo "Use --list to see known hosts." >&2
            exit 1
        fi
    done
}

add_all() {
    git add .
    git submodule foreach git add .
}

commit_and_push() {
    if [[ "$DO_GIT" == "true" ]]; then
        git submodule foreach "git diff-index --quiet HEAD || (git add -A && git commit -m \"${MESSAGE}\")"
        git diff-index --quiet HEAD || (git add -A && git commit -m "${MESSAGE}")
        git push --recurse-submodules=on-demand
    fi
}

do_refresh() {
    if [[ "$DO_REFRESH" == "true" ]]; then
        echo "==> Updating flake inputs..."
        nix flake update
    fi
}

get_master_identity() {
    # Returns path to the master identity file
    # Linux: Uses TPM to decrypt
    # macOS: Prompts for password to decrypt

    AGE_DECRYPTED_KEY="$AGE_RUNTIME_KEY"
    trap 'rm -f "$AGE_DECRYPTED_KEY"' EXIT

    if [[ "$(uname -s)" == "Darwin" ]]; then
        # macOS: Use password-protected key
        local password_key="${HOME}/age-key.age"
        if [[ ! -f "$password_key" ]]; then
            echo "Error: Password-protected master key not found: $password_key" >&2
            return 1
        fi

        echo "    Decrypting master key (enter password)..." >&2
        if age -d -o "$AGE_DECRYPTED_KEY" "$password_key"; then
            chmod 600 "$AGE_DECRYPTED_KEY"
            echo "$AGE_DECRYPTED_KEY"
            return 0
        else
            echo "Error: Failed to decrypt master key" >&2
            rm -f "$AGE_DECRYPTED_KEY"
            return 1
        fi
    else
        # Linux: Use TPM
        if [[ ! -f "$AGE_MASTER_KEY_TPM" ]]; then
            echo "Error: TPM-encrypted master key not found: $AGE_MASTER_KEY_TPM" >&2
            echo "Run ./enroll-tpm to set up TPM protection" >&2
            return 1
        fi

        if [[ ! -f "$AGE_TPM_IDENTITY" ]]; then
            echo "Error: TPM identity not found: $AGE_TPM_IDENTITY" >&2
            echo "Run ./enroll-tpm to set up TPM protection" >&2
            return 1
        fi

        if ! command -v age-plugin-tpm &>/dev/null; then
            echo "Error: age-plugin-tpm not found" >&2
            echo "Install it or run: nix shell nixpkgs#age-plugin-tpm" >&2
            return 1
        fi

        echo "    Decrypting master key via TPM..." >&2
        if age -d -i "$AGE_TPM_IDENTITY" -o "$AGE_DECRYPTED_KEY" "$AGE_MASTER_KEY_TPM" 2>/dev/null; then
            chmod 600 "$AGE_DECRYPTED_KEY"
            echo "$AGE_DECRYPTED_KEY"
            return 0
        else
            echo "Error: Failed to decrypt master key with TPM" >&2
            echo "Is the TPM available? Try: age -d -i $AGE_TPM_IDENTITY $AGE_MASTER_KEY_TPM" >&2
            rm -f "$AGE_DECRYPTED_KEY"
            return 1
        fi
    fi
}

cleanup_decrypted_key() {
    if [[ -n "$AGE_DECRYPTED_KEY" && -f "$AGE_DECRYPTED_KEY" ]]; then
        rm -f "$AGE_DECRYPTED_KEY"
        AGE_DECRYPTED_KEY=""
    fi
}

do_rekey() {
    if [[ "$DO_REKEY" == "true" ]]; then
        echo "==> Rekeying secrets for: ${HOSTS[*]}"
        add_all

        # Decrypt master key to the path expected by Nix config
        get_master_identity >/dev/null || exit 1

        local system
        system="$(uname -m)-$(uname -s | tr '[:upper:]' '[:lower:]')"

        for host in "${HOSTS[@]}"; do
            local group
            group=$(get_host_attr "$host" "group")

            local pubkey="${group_pubkeys[$group]}"
            if [[ -z "$pubkey" ]]; then
                echo "Warning: No pubkey configured for group '$group', skipping rekey for $host"
                continue
            fi

            echo "    Rekeying $host (group: $group)..."
            nix run ".?submodules=1#agenix-rekey-hosts.${host}.${system}.rekey"
        done

        cleanup_decrypted_key
    fi
}

do_build() {
    echo "==> Building: ${HOSTS[*]}"
    add_all
    mkdir -p "$ROOTS"

    for host in "${HOSTS[@]}"; do
        local platform
        platform=$(get_host_attr "$host" "platform")

        echo "    Building $host ($platform)..."
        case "$platform" in
            darwin)
                nix build ".?submodules=1#darwinConfigurations.${host}.system" \
                    --out-link "${ROOTS}/${host}"
                ;;
            linux)
                nix build ".?submodules=1#nixosConfigurations.${host}.config.system.build.toplevel" \
                    --out-link "${ROOTS}/${host}"
                ;;
            *)
                echo "Error: Unknown platform '$platform' for host '$host'" >&2
                exit 1
                ;;
        esac
    done

    commit_and_push
}

do_switch() {
    if [[ "$DO_SWITCH" == "true" ]]; then
        echo "==> Switching: ${HOSTS[*]}"
        add_all

        for host in "${HOSTS[@]}"; do
            local platform fqn closure
            platform=$(get_host_attr "$host" "platform")
            fqn=$(get_host_attr "$host" "fqn")
            closure=$(readlink -f "${ROOTS}/${host}")

            # null fqn means local deployment
            [[ "$fqn" == "null" || -z "$fqn" ]] && fqn=""

            echo "    Switching $host..."
            case "$platform" in
                darwin)
                    if [[ "$THISHOST" == "$host" || -z "$fqn" ]]; then
                        "${closure}/sw/bin/darwin-rebuild" switch --flake .
                    else
                        nix copy --to "ssh://${fqn}" "${ROOTS}/${host}"
                        ssh -t "${fqn}" sudo -H --preserve-env=PATH env nix-env -p /nix/var/nix/profiles/system --set "$closure"
                        ssh -t "${fqn}" "sudo ${closure}/sw/bin/darwin-rebuild" activate
                    fi
                    ;;
                linux)
                    if [[ "$THISHOST" == "$host" || -z "$fqn" ]]; then
                        sudo nix-env -p /nix/var/nix/profiles/system --set "$closure"
                        sudo /nix/var/nix/profiles/system/bin/switch-to-configuration switch
                    else
                        nix copy --to "ssh://root@${fqn}" "${ROOTS}/${host}"
                        ssh "root@$fqn" nix-env -p /nix/var/nix/profiles/system --set "$closure"
                        ssh "root@$fqn" /nix/var/nix/profiles/system/bin/switch-to-configuration switch
                    fi
                    ;;
            esac
        done

        commit_and_push
    fi
}

main() {
    parse_args "$@"

    if [[ "$DO_LIST" == "true" ]]; then
        list_hosts
    fi

    if [[ "$VERBOSE" == "true" ]]; then
        set -x
    fi

    cd "$SCRIPT_DIR"
    load_host_meta
    expand_host_specifiers
    validate_hosts

    do_refresh
    do_rekey
    do_build
    do_switch

    echo "==> Done!"
}

main "$@"
