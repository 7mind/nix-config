--- a/src/main.rs
+++ b/src/main.rs
@@ -22,6 +22,7 @@
 mod session_list;
 mod session_view;
 mod system_settings;
+mod tray;
 mod user_facing_error;
 mod utils;
 mod window;
@@ -32,6 +33,10 @@ use gettextrs::*;
 use gtk::{IconTheme, gdk::Display, gio};
 use tracing_subscriber::{EnvFilter, fmt, prelude::*};

+use std::ops::ControlFlow;
+use gio::prelude::*;
+use gtk::glib::{Char, OptionArg, OptionFlags};
+use gtk::subclass::prelude::ObjectSubclassIsExt;
 use self::{application::*, config::*, i18n::*, utils::OneshotNotifier, window::Window};

 /// The default tokio runtime to be used for async tasks
@@ -76,5 +81,21 @@ fn main() {
         .add_resource_path("/org/gnome/Fractal/icons");

     let app = Application::new();
+
+    // Register --minimized/-m option
+    app.add_main_option(
+        "minimized",
+        Char::from(b'm'),
+        OptionFlags::NONE,
+        OptionArg::None,
+        "Start minimized to system tray",
+        None,
+    );
+
+    app.connect_handle_local_options(|app, options| {
+        app.imp().start_minimized.set(options.contains("minimized"));
+        ControlFlow::Continue(())
+    });
+
     app.run();
 }
--- a/src/application.rs
+++ b/src/application.rs
@@ -25,8 +25,10 @@ pub(crate) const APP_HOMEPAGE_URL: &str = "https://gitlab.gnome.org/World/fracta

 mod imp {
     use std::cell::Cell;
+    use std::cell::OnceCell;

     use super::*;
+    use crate::tray::{spawn_tray, TrayCommand, TrayHandle};

     #[derive(Debug)]
     pub struct Application {
@@ -38,6 +40,10 @@ mod imp {
         pub(super) session_list: SessionList,
         intent_handler: BoundObjectWeakRef<glib::Object>,
         last_network_state: Cell<NetworkState>,
+        /// Whether the app was started with --minimized flag.
+        pub start_minimized: Cell<bool>,
+        /// System tray handle.
+        pub tray_handle: OnceCell<TrayHandle>,
     }

     impl Default for Application {
@@ -48,6 +54,8 @@ mod imp {
                 session_list: Default::default(),
                 intent_handler: Default::default(),
                 last_network_state: Default::default(),
+                start_minimized: Cell::new(false),
+                tray_handle: OnceCell::new(),
             }
         }
     }
@@ -89,6 +97,24 @@ mod imp {
                 }
             ));

+            // Initialize system tray
+            let mut tray_handle = spawn_tray();
+            let tray_rx = tray_handle.take_receiver();
+            let _ = self.tray_handle.set(tray_handle);
+
+            if let Some(mut rx) = tray_rx {
+                spawn!(clone!(
+                    #[weak(rename_to = obj)]
+                    self.obj(),
+                    async move {
+                        while let Some(cmd) = rx.recv().await {
+                            match cmd {
+                                TrayCommand::Show => { obj.imp().present_main_window(); }
+                                TrayCommand::Quit => { obj.quit(); }
+                            }
+                        }
+                    }
+                ));
+            }
+
             // Watch the network to log its state.
             let network_monitor = gio::NetworkMonitor::default();
             network_monitor.connect_network_changed(clone!(
@@ -148,6 +174,18 @@ mod imp {
         ///
         /// Returns the main window.
         fn present_main_window(&self) -> Window {
+            // Clear tray unread indicator when presenting window
+            if let Some(tray) = self.tray_handle.get() {
+                tray.set_has_unread(false);
+            }
+
+            // If started with --minimized, skip presentation on first call only
+            if self.start_minimized.replace(false) {
+                let window = if let Some(window) = self.obj().active_window().and_downcast() {
+                    window
+                } else {
+                    Window::new(&self.obj())
+                };
+                return window;
+            }
             let window = if let Some(window) = self.obj().active_window().and_downcast() {
                 window
             } else {
--- a/src/session/notifications/mod.rs
+++ b/src/session/notifications/mod.rs
@@ -144,6 +144,11 @@ impl Notifications {
         }

         Application::default().send_notification(Some(id), &notification);
+
+        // Update tray unread indicator
+        if let Some(tray) = Application::default().imp().tray_handle.get() {
+            tray.set_has_unread(true);
+        }
     }

     /// Ask the system to show the given push notification, if applicable.
--- a/src/window.rs
+++ b/src/window.rs
@@ -203,7 +203,9 @@ mod imp {
                 warn!("Could not save current session: {error}");
             }

-            glib::Propagation::Proceed
+            // Hide to tray instead of closing
+            self.obj().set_visible(false);
+            glib::Propagation::Stop
         }
     }

--- a/src/session_view/sidebar/mod.blp
+++ b/src/session_view/sidebar/mod.blp
@@ -28,6 +28,13 @@
       action: "app.about";
     }
   }
+
+  section {
+    item {
+      label: _("_Quit");
+      action: "app.quit";
+    }
+  }
 }
